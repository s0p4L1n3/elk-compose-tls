###########################################
#                                         #
#                                         #
# Ingest Pipeline Conversion for Logstash #
# winlogbeat-security			  #
# This parser is translated from Elastic  #
# Ingest Pipelines (painless script       #
# language)                               #
#                                         #
###########################################


# Filters applies only if Chanel security
filter {
  if [winlog][channel] =~ "Security" {

    # Set value of "event.module" to "security"
    mutate { add_field => { "[event][module]" => "security" } }
   

    # Convert "event.code" to type "string"
    mutate { convert => { "[event][code]" => "string" } }
    
    # Set ECS categorization fields
    if ([event][code]) {
      ruby {
       init => "
         require 'csv'
         # Load ECS categorization parameters from CSV
         @ecs = {}
         CSV.foreach('/usr/share/logstash/pipeline/winlogbeat/csv/security/Windows-ECS-Categorization-Fields.csv', headers: true) do |row|
           # Create a hash for each event code with keys 'action', 'category', and 'type'
           @ecs[row['EventCode']] = { 'action' => row['action'], 'category' => row['category'], 'type' => row['type'] }
         end
       "
       code => "
         # Retrieve the event code from [event][code]
         code = event.get('[event][code]')
         # If a mapping exists for this event code, set the corresponding ECS fields
         if code && @ecs.has_key?(code)
           @ecs[code].each do |key, value|
             # Overwrite existing fields by setting them at the root level
             event.set(key, value)
           end
         end
       "
     }
   }
 

    # Set Logon Type 
    if [winlog][event_data][LogonType] {
      translate {
        source => "[winlog][event_data][LogonType]"
        target => "[winlog][event_data][LogonTypeDescription]"
        dictionary_path => "/usr/share/logstash/pipeline/winlogbeat/csv/security/Windows-LogonType-to-LogonDescription.csv"
        refresh_interval => 60
        refresh_behaviour => replace
        fallback => "No Description Found"
        }
    }
  

    # Set User Account Control
    if [winlog][event_data][NewUacValue] {
    
      #Convert to long integer
      ruby {
        code => "
          # Convert the hex value of NewUacValue to an integer
          newUacValue = event.get('[winlog][event_data][NewUacValue]').to_i(16)

          # Initialize an array to store the extracted bit flags
          uacResult = []

          # Loop through the 32 bits (0 to 31)
          (0..31).each do |b|
            # Calculate the flag value by shifting 1 to the left by b positions
            flag = 1 << b

            # Check if the flag is present in newUacValue using a binary AND
            if (newUacValue & flag) == flag
              # Add the flag to the bit_flags array, formatting as hexadecimal
              uacResult << '0x%08X' % flag
            end
          end
          event.set('[winlog][event_data][NewUacValueBit_flags]', uacResult)
        "
      }
     
      ruby {
        init => "
          require 'csv'
          #Initialize an empty hash to store the translations
          @translate_map = {}
          CSV.foreach('/usr/share/logstash/pipeline/winlogbeat/csv/security/Windows-UACValue-to-UACValue_description.csv', headers: false) do |row|
            @translate_map[row[0]] = row[1]
        end
      "
      code => "
        # Retrieve the bit flags array from the event
        uac_flags = event.get('[winlog][event_data][NewUacValueBit_flags]')
        descriptions = []
        # Initialize an array to store the descriptions
        if uac_flags
          # Iterate through each flag in the bit flags array
          uac_flags.each do |flag|
               # Get the description from the translate_map hash using the flag as the key
            description = @translate_map[flag]

               # If a description is found, add it to the descriptions array
            if description
              descriptions << description
            else
              puts 'No Description Dound for flag:', flag
            end
          end
        else
          puts 'uac_flags is nil!'
        end
        event.set('[winlog][event_data][NewUacValueDescription]', descriptions)
      "
      }
   }

    
    # Set Kerberos Ticket Options
    if [winlog][event_data][TicketOptions] {
    
      #Convert to long integer
      ruby {
        code => "
          # Convert the hex value of TicketOptions to an integer
          tOpts = event.get('[winlog][event_data][TicketOptions]').to_i(16)
          
          # Initialize an array to store the extracted bit flags
          bit_flags = []
      
          # Loop through the 32 bits (0 to 31)
          (0..31).each do |b|
            # Calculate the flag value by shifting 1 to the left by b positions
            flag = 1 << b
 
            # Check if the flag is present in tOpts using a binary AND 
            if (tOpts & flag) == flag
              # Add the flag to the bit_flags array, formatting as hexadecimal
              bit_flags << '0x%08X' % flag
            end
          end
          event.set('[winlog][event_data][TicketOptionsBit_flags]', bit_flags)
        "
      }

      ruby {
        init => "
          require 'csv'
          #Initialize an empty hash to store the translations
          @translate_map = {}
          CSV.foreach('/usr/share/logstash/pipeline/winlogbeat/csv/security/Windows-Kerberos-ticketoption-to-ticketoption_description.csv', headers: false) do |row|
            @translate_map[row[0]] = row[1]
        end
      "
      code => "
        # Retrieve the bit flags array from the event
        bits_flags = event.get('[winlog][event_data][TicketOptionsBit_flags]')
        descriptions = []
        # Initialize an array to store the descriptions
        if bits_flags
          # Iterate through each flag in the bit flags array
          bits_flags.each do |flag|
               # Get the description from the translate_map hash using the flag as the key
            description = @translate_map[flag]

               # If a description is found, add it to the descriptions array
            if description
              descriptions << description
            else
              puts 'No Description Found for flag:', flag
            end
          end
            # Reverse the descriptions array to match the order from right to left as per Microsoft documentation
          descriptions.reverse!
        else
          puts 'bit_flags is nil!'
        end
        event.set('[winlog][event_data][TicketOptionsDescription]', descriptions) 
      "
      }
    }


    # Set Kerberos Encryption Types
    if [winlog][event_data][EncryptionType] {
      translate {
        source => "[winlog][event_data][TicketEncryptionType]"
        target => "[winlog][event_data][TicketEncryptionTypeDescription]"
        dictionary_path => "/usr/share/logstash/pipeline/winlogbeat/csv/security/Windows-Kerberos-EncryptionType-to-EncryptionTypeDescription.csv"
        refresh_interval => 60
        refresh_behaviour => replace
        fallback => "No Description Found"
        }
    }

    # Set 4525 or 4776 Ticket Status Description
    if ([event][code] in ["4625", "4776"] and [winlog][event_data][Status]) {
      translate {
        source => "[winlog][event_data][Status]"
        target => "[winlog][event_data][StatusDescription]"
        dictionary_path => "/usr/share/logstash/pipeline/winlogbeat/csv/security/Windows-Status-StatusDescription.csv"
        refresh_interval => 60
        refresh_behaviour => replace
        fallback => "No Description Found"
        }
    }


   # Set ServiceTypeDescription (EventID 4697)
   # https://learn.microsoft.com/en-us/previous-versions/windows/it-pro/windows-10/security/threat-protection/auditing/event-4697
    if [winlog][event_id] =~ "4697" {
      translate {
        source => "[winlog][event_data][ServiceType]"
        target => "[winlog][event_data][ServiceTypeDescription]"
        dictionary_path => "/usr/share/logstash/pipeline/winlogbeat/csv/security/Windows-ServiceTypeDescription.csv"
        refresh_interval => 60
        refresh_behaviour => replace
        fallback => "No Description Found"
        }
    }

   # Set ServiceStartTypeDescription (EventID 4697)
   # https://learn.microsoft.com/en-us/previous-versions/windows/it-pro/windows-10/security/threat-protection/auditing/event-4697
    if [winlog][event_id] =~ "4697" {
      translate {
        source => "[winlog][event_data][ServiceStartType]"
        target => "[winlog][event_data][ServiceStartTypeDescription]"
        dictionary_path => "/usr/share/logstash/pipeline/winlogbeat/csv/security/Windows-ServiceStartTypeDescription.csv"
        refresh_interval => 60
        refresh_behaviour => replace
        fallback => "No Description Found"
        }
    }


    # Set Audit Information
    # https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-gpac/77878370-0712-47cd-997d-b07053429f6d
    if [winlog][event_data][SubcategoryGuid] {
    ruby {
      init => "
        require 'csv'
        @subcategory_map = {}
        # Read the CSV file with headers. The CSV is expected to have:
        # 'SubcategoryGuid', 'SubCategory', and 'Category'
        CSV.foreach('/usr/share/logstash/pipeline/winlogbeat/csv/security/Windows-Subcategory_Mapping.csv', headers: true) do |row|
          # Normalize the GUID by removing braces and converting to uppercase
          key = row['SubcategoryGuid'].gsub('{','').gsub('}','').upcase
          @subcategory_map[key] = [row['SubCategory'], row['Category']]
        end
      "
      code => "
        # Retrieve the SubcategoryGuid field from the event
        guid = event.get('[winlog][event_data][SubcategoryGuid]')
        # If the GUID is nil, exit the Ruby code
        if guid.nil?
          return
        end
        # Normalize the GUID (remove '{' and '}' and convert to uppercase)
        norm_guid = guid.gsub('{','').gsub('}','').upcase
        # Check if the normalized GUID exists in the dictionary
        if @subcategory_map.has_key?(norm_guid)
          mapping = @subcategory_map[norm_guid]
          # Set the fields: SubCategory gets the first element, Category the second
          event.set('[winlog][event_data][SubCategory]', mapping[0])
          event.set('[winlog][event_data][Category]', mapping[1])
        end
      "
    }
  }


    # Decode Message Table
    ruby {
    init => "
      require 'csv'
      # Load the general descriptions mapping from CSV.
      @descriptions = {}
      CSV.foreach('/usr/share/logstash/pipeline/winlogbeat/csv/security/Windows-DecodeMessageTable.csv', headers: true) do |row|
        @descriptions[row['Code']] = row['Description']
      end

      # Load the AccessMask descriptions mapping from CSV.
      @AccessMaskDescriptions = {}
      CSV.foreach('/usr/share/logstash/pipeline/winlogbeat/csv/security/Windows-DecodeAccessMaskDescriptions.csv', headers: true) do |row|
        @AccessMaskDescriptions[row['Code']] = row['Description']
      end
    "
    code => "
      # --- Processing FailureReason ---
      failure_reason = event.get('[winlog][event_data][FailureReason]')
      if failure_reason
        # Remove occurrences of '%%'
        code_value = failure_reason.gsub('%%', '')
        if @descriptions.has_key?(code_value)
          # Ensure the nested structure winlog.logon.failure exists
          winlog = event.get('winlog') || {}
          logon = winlog['logon'] || {}
          failure = logon['failure'] || {}
          failure['reason'] = @descriptions[code_value]
          logon['failure'] = failure
          winlog['logon'] = logon
          event.set('winlog', winlog)
        end
      end

      # --- Processing AccessMask ---
      access_mask_str = event.get('[winlog][event_data][AccessMask]')
      if access_mask_str
        list = []
        accessMask = 0
        # Split the AccessMask string by whitespace
        #@split_string.call(access_mask_str).each do |elem|
        access_mask_str.split(/\\s+/).each do |elem|
          next if elem.length == 0
          list << elem
          code_value = elem.gsub('%%', '').strip
          begin
            accessMask |= Integer(code_value, 16)
          rescue
            # Ignore conversion errors
          end
        end
        if list.length > 0
          # Overwrite the AccessMask field with the list of tokens
          event.set('[winlog][event_data][AccessMask]', list)
        end

        desc = []
        # For each bit (0 to 31), check if the flag is set in the cumulative mask.
        32.times do |b|
          flag = 1 << b
          if (accessMask & flag) == flag
            key = format('0x%08X', flag)
            fDesc = @AccessMaskDescriptions[key]
            if fDesc
              desc << fDesc
            end
          end
        end
        if desc.length > 0
          event.set('[winlog][event_data][AccessMaskDescription]', desc)
        end
      end
    "
  }
    
    # AccessList Split Array
    if [winlog][event_data][AccessList] {
       mutate {
          # Replace any sequence of whitespace (spaces, newlines, tabs, etc.) with a single space.
          gsub => [ "[winlog][event_data][AccessList]", "\\s+", " " ]
          # Now split the field using a single space as the delimiter.
          split => { "[winlog][event_data][AccessList]" => " " }
        }
    }

    # AuditPolicyChanges Split Array
    if [winlog][event_data][AuditPolicyChanges] {
       mutate {
          # Replace any sequence of whitespace (spaces, newlines, tabs, etc.) with a single space.
          gsub => [ "[winlog][event_data][AuditPolicyChanges]", "\\s+", " " ]
          # Now split the field using a single space as the delimiter.
          split => { "[winlog][event_data][AuditPolicyChanges]" => " " }
        }
    }

    
    # Set Trust Type (EventID 4716 OR 4706)
    #https://learn.microsoft.com/en-us/previous-versions/windows/it-pro/windows-10/security/threat-protection/auditing/event-4716
    #https://learn.microsoft.com/en-us/previous-versions/windows/it-pro/windows-10/security/threat-protection/auditing/event-4706
    if [winlog][event_data][TdoType] {
      translate {
        source => "[winlog][event_data][TdoType]"
        target => "[winlog][event_data][TdoTypeDescription]"
        dictionary_path => "/usr/share/logstash/pipeline/winlogbeat/csv/security/Windows-TrustType-to-TrustTypeDescription.csv"
        refresh_interval => 60
        refresh_behaviour => replace
        fallback => "No Description Found"
        }
    }
    
    
   # Set Trust Direction (EventID 4706)
   #https://learn.microsoft.com/en-us/previous-versions/windows/it-pro/windows-10/security/threat-protection/auditing/event-4706
   if [winlog][event_data][TdoDirection] {
      translate {
        source => "[winlog][event_data][TdoType]"
        target => "[winlog][event_data][TdoDirectionDescription]"
        dictionary_path => "/usr/share/logstash/pipeline/winlogbeat/csv/security/Windows-TrustDirection-to-TrustDirectionDescription.csv"
        refresh_interval => 60
        refresh_behaviour => replace
        fallback => "No Description Found"
        }
    }
   
   # Set Trust Attributes (EventID 4706)
   #https://learn.microsoft.com/en-us/previous-versions/windows/it-pro/windows-10/security/threat-protection/auditing/event-4706
   if [winlog][event_data][TdoAttributes] {
      translate {
        source => "[winlog][event_data][TdoAttributes]"
        target => "[winlog][event_data][TdoAttributesDescription]"
        dictionary_path => "/usr/share/logstash/pipeline/winlogbeat/csv/security/Windows-TrustAttributes-to-TrustAttributesDescription.csv"
        refresh_interval => 60
        refresh_behaviour => replace
        fallback => "No Description Found"
        }
    }

   # Add Session Events
   ruby {
    code => "
      # Check if event.code exists and is either '4778' or '4779'
      event_code = event.get('[event][code]')
      if event_code.nil? or !['4778', '4779'].include?(event_code)
        return
      end

      # --- Process AccountName ---
      # If [winlog][event_data][AccountName] exists, map it to user.name and add it to related.user array
      account_name = event.get('[winlog][event_data][AccountName]')
      if account_name
        # Retrieve or initialize the 'user' and 'related' objects
        user = event.get('user') || {}
        related = event.get('related') || {}

        # Retrieve or initialize the 'related.user' array
        related_user = related['user'] || []
        # Set user.name to AccountName
        user['name'] = account_name
        # Add the AccountName to related.user if not already present
        if !related_user.include?(account_name)
          related_user << account_name
        end
        # Save the updates back to the event
        user = user
        related['user'] = related_user
        event.set('user', user)
        event.set('related', related)
      end

      # --- Process AccountDomain ---
      # If [winlog][event_data][AccountDomain] exists, map it to user.domain
      account_domain = event.get('[winlog][event_data][AccountDomain]')
      if account_domain
        user = event.get('user') || {}
        user['domain'] = account_domain
        event.set('user', user)
      end

      # --- Process ClientAddress ---
      # If [winlog][event_data][ClientAddress] exists and is not '-' or 'Unknown', map it to source.ip 
      # and add it to related.ip array.
      client_address = event.get('[winlog][event_data][ClientAddress]')
      if client_address and client_address != '-' and client_address != 'Unknown'
        # Correct invalid IP address 'LOCAL'
        if client_address == 'LOCAL'
          client_address = '127.0.0.1'
          event.set('[winlog][event_data][ClientAddress]', client_address)
        end
        source = event.get('source') || {}
        related = event.get('related') || {}
        related_ip = related['ip'] || []
        # Set source.ip to the client address
        source['ip'] = client_address
        # Add the client address to related.ip if not already present
        if !related_ip.include?(client_address)
          related_ip << client_address
        end
        event.set('source', source)
        related['ip'] = related_ip
        event.set('related', related)
      end

      # --- Process ClientName ---
      # If [winlog][event_data][ClientName] exists, map it to source.domain
      client_name = event.get('[winlog][event_data][ClientName]')
      if client_name
        source = event.get('source') || {}
        source['domain'] = client_name
        event.set('source', source)
      end

      # --- Process LogonID ---
      # If [winlog][event_data][LogonID] exists, map it to winlog.logon.id
      logon_id = event.get('[winlog][event_data][LogonID]')
      if logon_id
        winlog = event.get('winlog') || {}
        logon = winlog['logon'] || {}
        logon['id'] = logon_id
        winlog['logon'] = logon
        event.set('winlog', winlog)
      end
    "
  }


   #Copy Target User
   ruby {
    code => "
      # Check if event.code exists and is one of the allowed values
      event_code = event.get('[event][code]')
      allowed_codes = ['4624', '4625', '4634', '4647', '4648', '4768', '4769', '4770', '4771', '4776', '4964']
      if event_code.nil? or !allowed_codes.include?(event_code)
        return
      end

      # Determine targetUserId from either TargetUserSid or TargetSid
      targetUserId = event.get('[winlog][event_data][TargetUserSid]')
      if targetUserId.nil?
        targetUserId = event.get('[winlog][event_data][TargetSid]')
      end

      # Map targetUserId to user.id if not already set; otherwise, map to user.target.id
      if !targetUserId.nil?
        user = event.get('user') || {}
        if user['id'].nil?
          user['id'] = targetUserId
        else
          target_obj = user['target'] || {}
          target_obj['id'] = targetUserId
          user['target'] = target_obj
        end
        event.set('user', user)
      end

      # Process TargetUserName: split the value on the '@' token,
      # then map the first part to user.name (or user.target.name if user.name already exists)
      # and add it to the related.user array.
      targetUserName = event.get('[winlog][event_data][TargetUserName]')
      if targetUserName
        tun = targetUserName.split('@')
        user = event.get('user') || {}
        if user['name'].nil?
          user['name'] = tun[0]
        else
          target_obj = user['target'] || {}
          target_obj['name'] = tun[0]
          user['target'] = target_obj
        end
        event.set('user', user)

        # Ensure related.user is an array and add the username if not already present
        related = event.get('related') || {}
        related_user = related['user'] || []
        unless related_user.include?(tun[0])
          related_user << tun[0]
        end
        related['user'] = related_user
        event.set('related', related)
      end

      # Process TargetDomainName: map to user.domain if not set; otherwise, map to user.target.domain
      targetDomainName = event.get('[winlog][event_data][TargetDomainName]')
      if targetDomainName
        user = event.get('user') || {}
        if user['domain'].nil?
          user['domain'] = targetDomainName
        else
          target_obj = user['target'] || {}
          target_obj['domain'] = targetDomainName
          user['target'] = target_obj
        end
        event.set('user', user)
      end
    "
  }

  
   #Copy MemberName to User and User to Group
   ruby {
    code => "
      # Check if event.code exists and is one of the allowed values.
      event_code = event.get('[event][code]')
      allowed_codes = ['4727', '4728', '4729', '4730', '4731', '4732', '4733', '4734', '4735', '4737', '4744', '4745', '4746', '4747', '4748', '4749', '4750', '4751', '4752', '4753', '4754', '4755', '4756', '4757', '4758', '4759', '4760', '4761', '4762', '4763', '4764', '4799']
      if event_code.nil? or !allowed_codes.include?(event_code)
        return
      end

      # Process MemberName: extract and clean the member name.
      memberName = event.get('[winlog][event_data][MemberName]')
      if memberName
        # Split the string on commas.
        memberNameParts = memberName.split(',')
        # Remove 'CN=' or 'cn=' (case-insensitive) from the first part.
        memberNameClean = memberNameParts[0].gsub(/CN=/i, '')
        
        # Initialize or update the related.user array.
        related = event.get('related') || {}
        related_user = related['user'] || []
        unless related_user.include?(memberNameClean)
          related_user << memberNameClean
        end
        related['user'] = related_user
        event.set('related', related)
        
        # Initialize or update the user and user.target objects.
        user = event.get('user') || {}
        target = user['target'] || {}
        target['name'] = memberNameClean
        # If there are at least 4 parts, extract the domain from the 4th part.
        if memberNameParts.length >= 4
          domain = memberNameParts[3].gsub(/DC=/i, '')
          target['domain'] = domain
        end
        user['target'] = target
        event.set('user', user)
      end

      # Process TargetUserSid: map to group.id.
      targetUserSid = event.get('[winlog][event_data][TargetUserSid]')
      if targetUserSid
        group = event.get('group') || {}
        group['id'] = targetUserSid
        event.set('group', group)
      end

      # Process TargetSid: if available, override group.id.
      targetSid = event.get('[winlog][event_data][TargetSid]')
      if targetSid
        group = event.get('group') || {}
        group['id'] = targetSid
        event.set('group', group)
      end

      # Process TargetUserName: map to group.name.
      targetUserName = event.get('[winlog][event_data][TargetUserName]')
      if targetUserName
        group = event.get('group') || {}
        group['name'] = targetUserName
        event.set('group', group)
      end

      # Process TargetDomainName: remove 'DC=' or 'dc=' and map to group.domain.
      targetDomainName = event.get('[winlog][event_data][TargetDomainName]')
      if targetDomainName
        group = event.get('group') || {}
        domain = targetDomainName.gsub(/DC=/i, '')
        group['domain'] = domain
        event.set('group', group)
      end

      # Finally, if user.target exists, copy group information into user.target.group.
      user = event.get('user') || {}
      target = user['target']
      if target
        target_group = target['group'] || {}
        group = event.get('group') || {}
        if group['id']
          target_group['id'] = group['id']
        end
        if group['name']
          target_group['name'] = group['name']
        end
        if group['domain']
          target_group['domain'] = group['domain']
        end
        target['group'] = target_group
        user['target'] = target
        event.set('user', user)
      end
    "
  }


   #Copy Target User to Computer Object
   ruby {
    code => "
      # Retrieve the event code and verify it is one of the allowed values.
      code_val = event.get('[event][code]')
      allowed_codes = ['4741', '4742', '4743']
      if code_val.nil? or !allowed_codes.include?(code_val)
        return
      end

      # Retrieve the 'winlog' object (or initialize it as an empty hash if it doesn't exist)
      winlog = event.get('winlog') || {}

      # Retrieve the 'computerObject' from winlog, or initialize it if needed.
      computerObject = winlog['computerObject'] || {}

      # If TargetSid exists, set it as the 'id' in computerObject.
      targetSid = event.get('[winlog][event_data][TargetSid]')
      if targetSid
        computerObject['id'] = targetSid
      end

      # If TargetUserName exists, set it as the 'name' in computerObject.
      targetUserName = event.get('[winlog][event_data][TargetUserName]')
      if targetUserName
        computerObject['name'] = targetUserName
      end

      # If TargetDomainName exists, set it as the 'domain' in computerObject.
      targetDomainName = event.get('[winlog][event_data][TargetDomainName]')
      if targetDomainName
        computerObject['domain'] = targetDomainName
      end

      # Update the winlog object with the modified computerObject.
      winlog['computerObject'] = computerObject
      event.set('winlog', winlog)
    "
  }

   #Sets value of "winlog.logon.id" to the value of "winlog.event_data.TargetLogonId"
   if ([event][code] and ([event][code] in ["4634", "4647", "4964"])) {
     if ([winlog][event_data][TargetLogonId]) {
       mutate {
         copy => { "[winlog][event_data][TargetLogonId]" => "[winlog][logon][id]" }
       }
     }
   }
   

   #Copy Subject User from Event Data
   if ([event][code] and ([event][code] in ["4657", "4670", "4672", "4673", "4674", "4688", "4689", "4697", "4698", "4699", "4700", "4701", "4702", "4706", "4707", "4713", "4716", "4717", "4718", "4719", "4720", "4722", "4723", "4724", "4725", "4726", "4727", "4728", "4729", "4730", "4731", "4732", "4733", "4734", "4735", "4737", "4738", "4739", "4740", "4741", "4742", "4743", "4744", "4745", "4746", "4747", "4748", "4749", "4750", "4751", "4752", "4753", "4754", "4755", "4756", "4757", "4758", "4759", "4760", "4761", "4762", "4763", "4764", "4767", "4781", "4798", "4799", "4817", "4904", "4905", "4907", "4912", "4648", "4797", "5140", "5145", "5379", "5380", "5381", "5382"])) {

     ruby {
      code => "
        # Process SubjectUserSid: if present, set it to user.id
        subjectUserSid = event.get('[winlog][event_data][SubjectUserSid]')
        if subjectUserSid
          user = event.get('user') || {}
          user['id'] = subjectUserSid
          event.set('user', user)
        end

        # Process SubjectUserName: if present, set it to user.name and add it to related.user array
        subjectUserName = event.get('[winlog][event_data][SubjectUserName]')
        if subjectUserName
          user = event.get('user') || {}
          related = event.get('related') || {}
          related_user = related['user'] || []

          # Set user.name
          user['name'] = subjectUserName

          # Add the username to the related.user array if not already present
          if !related_user.include?(subjectUserName)
            related_user << subjectUserName
          end

          related['user'] = related_user
          event.set('user', user)
          event.set('related', related)
        end

        # Process SubjectDomainName: if present, set it to user.domain
        subjectDomainName = event.get('[winlog][event_data][SubjectDomainName]')
        if subjectDomainName
          user = event.get('user') || {}
          user['domain'] = subjectDomainName
          event.set('user', user)
        end
      "
     }
   }
   

   #Copy Target User to Target
   if ([event][code] and ([event][code] in ["4670", "4720", "4722", "4723", "4724", "4725", "4726", "4738", "4740", "4767", "4798", "4817", "4907", "4797"])) {
    ruby {
      code => "
        # Initialize or retrieve the 'user' object.
        user = event.get('user') || {}
        # Ensure the 'user.target' object exists.
        if user['target'].nil?
          user['target'] = {}
        end

        # Process TargetSid: if present and not empty or '-', set it as user.target.id.
        targetSid = event.get('[winlog][event_data][TargetSid]')
        if targetSid and targetSid != '' and targetSid != '-'
          user['target']['id'] = targetSid
        end

        # Process TargetUserName: if present and not empty or '-', set it as user.target.name.
        # Also, split the username on '@' and keep only the first part.
        targetUserName = event.get('[winlog][event_data][TargetUserName]')
        if targetUserName and targetUserName != '' and targetUserName != '-'
          user['target']['name'] = targetUserName
          parts = targetUserName.split('@')
          if parts.length > 1
            user['target']['name'] = parts[0]
          end

          # Ensure the 'related.user' array exists and add the username if it's not already present.
          related = event.get('related') || {}
          related_user = related['user'] || []
          if !related_user.include?(user['target']['name'])
            related_user << user['target']['name']
          end
          related['user'] = related_user
          event.set('related', related)
        end

        # Process TargetDomainName: if present and not empty or '-', set it as user.target.domain.
        targetDomainName = event.get('[winlog][event_data][TargetDomainName]')
        if targetDomainName and targetDomainName != '' and targetDomainName != '-'
          user['target']['domain'] = targetDomainName
        end

        # Update the event with the modified user object.
        event.set('user', user)

        # If user.target exists but is empty, remove it.
        if user.has_key?('target') and user['target'].empty?
          user.delete('target')
          event.set('user', user)
        end
      "
    }
  }

   
   #Copy Target User to Effective
   if ([event][code] and ([event][code] in ["4648", "4688"])) {
    ruby {
      code => "
        # Retrieve or initialize the 'user' object.
        user = event.get('user') || {}

        # Ensure that 'user.effective' exists as a hash.
        if user['effective'].nil?
          user['effective'] = {}
        end
        effectiveUser = user['effective']

        # Process TargetUserSid:
        # If present, non-empty, and not '-', set it to effectiveUser.id.
        targetUserSid = event.get('[winlog][event_data][TargetUserSid]')
        if targetUserSid and targetUserSid != '' and targetUserSid != '-'
          effectiveUser['id'] = targetUserSid
        end

        # Process TargetUserName:
        # If present, non-empty, and not '-', set it to effectiveUser.name.
        targetUserName = event.get('[winlog][event_data][TargetUserName]')
        if targetUserName and targetUserName != '' and targetUserName != '-'
          effectiveUser['name'] = targetUserName
          parts = targetUserName.split('@')
          if parts.length > 1
            effectiveUser['name'] = parts[0]
          end

          # Ensure the related.user array exists and add the effective user name if not already present.
          related = event.get('related') || {}
          relatedUser = related['user'] || []
          if !relatedUser.include?(effectiveUser['name'])
            relatedUser << effectiveUser['name']
          end
          related['user'] = relatedUser
          event.set('related', related)
        end

        # Process TargetDomainName:
        # If present, non-empty, and not '-', set it to effectiveUser.domain.
        targetDomainName = event.get('[winlog][event_data][TargetDomainName]')
        if targetDomainName and targetDomainName != '' and targetDomainName != '-'
          effectiveUser['domain'] = targetDomainName
        end

        # Update the 'user' object with the modified effective details.
        user['effective'] = effectiveUser
        event.set('user', user)

        # If effectiveUser is empty, remove the 'effective' field from user.
        if effectiveUser.empty?
          user.delete('effective')
          event.set('user', user)
        end
      "
    }
  }

   
   #Copy Subject User from user_data
   if ([event][code] and ([event][code] in ["1102"])) {
    ruby {
      code => "
        # Process SubjectUserSid: set user.id to winlog.user_data.SubjectUserSid if it exists.
        subjectUserSid = event.get('[winlog][user_data][SubjectUserSid]')
        if subjectUserSid
          user = event.get('user') || {}
          user['id'] = subjectUserSid
          event.set('user', user)
        end

        # Process SubjectUserName: set user.name and add to related.user array.
        subjectUserName = event.get('[winlog][user_data][SubjectUserName]')
        if subjectUserName
          user = event.get('user') || {}
          user['name'] = subjectUserName
          event.set('user', user)

          related = event.get('related') || {}
          related_user = related['user'] || []
          if !related_user.include?(subjectUserName)
            related_user << subjectUserName
          end
          related['user'] = related_user
          event.set('related', related)
        end

        # Process SubjectDomainName: set user.domain if available.
        subjectDomainName = event.get('[winlog][user_data][SubjectDomainName]')
        if subjectDomainName
          user = event.get('user') || {}
          user['domain'] = subjectDomainName
          event.set('user', user)
        end
      "
    }
  }
  
    
   #Sets value of "winlog.logon.id" to the value of "winlog.event_data.SubjectLogonId"
   mutate {
     copy => { "[winlog][event_data][SubjectLogonId]" => "[winlog][logon][id]" }
   }


   #Sets value of "winlog.logon.id" to the value of "winlog.event_data.SubjectLogonId"
   if ([event][code] and ([event][code] in ["1102"])) {
     mutate {
       copy => { "[winlog][event_data][SubjectLogonId]" => "[winlog][logon][id]" }
     }
   }


   #Rename Common Auth Fields
   if ([event][code] and ([event][code] in ["1100", "1102", "1104", "1105", "1108", "4624", "4648", "4625", "4670", "4673", "4674", "4689", "4697", "4719", "4720", "4722", "4723", "4724", "4725", "4726", "4727", "4728", "4729", "4730", "4731", "4732", "4733", "4734", "4735", "4737", "4738", "4740", "4741", "4742", "4743", "4744", "4745", "4746", "4747", "4748", "4749", "4750", "4751", "4752", "4753", "4754", "4755", "4756", "4757", "4758", "4759", "4760", "4761", "4762", "4763", "4764", "4767", "4768", "4769", "4770", "4771", "4798", "4799", "4817", "4904", "4905", "4907", "4912", "5140", "5145"])) {
     ruby {
       code => "
         # Process ProcessId: If it exists, convert if necessary, set to process.pid and remove from winlog.event_data.
         processId = event.get('[winlog][event_data][ProcessId]')
         if processId
           proc_obj = event.get('process') || {}
           if processId.is_a?(String)
             begin
               pid = Integer(processId)
             rescue
               pid = processId
             end
             proc_obj['pid'] = pid
           else
             proc_obj['pid'] = processId
           end
           event.set('process', proc_obj)
           # Remove ProcessId from winlog.event_data
           winlog = event.get('winlog') || {}
           event_data = winlog['event_data'] || {}
           event_data.delete('ProcessId')
           winlog['event_data'] = event_data
           event.set('winlog', winlog)
         end

         # Process ProcessName: If it exists, set process.executable and remove ProcessName.
         processName = event.get('[winlog][event_data][ProcessName]')
         if processName
           proc_obj = event.get('process') || {}
           proc_obj['executable'] = processName
           event.set('process', proc_obj)
           winlog = event.get('winlog') || {}
           event_data = winlog['event_data'] || {}
           event_data.delete('ProcessName')
           winlog['event_data'] = event_data
           event.set('winlog', winlog)
         end

         # Process IpAddress: If exists and not '-', set to source.ip and remove IpAddress.
         ipAddress = event.get('[winlog][event_data][IpAddress]')
         if ipAddress and ipAddress != '-'
           source = event.get('source') || {}
           source['ip'] = ipAddress
           event.set('source', source)
           winlog = event.get('winlog') || {}
           event_data = winlog['event_data'] || {}
           event_data.delete('IpAddress')
           winlog['event_data'] = event_data
           event.set('winlog', winlog)
         end

         # Process IpPort: If exists and not '-', convert to integer and set to source.port, then remove IpPort.
         ipPort = event.get('[winlog][event_data][IpPort]')
         if ipPort and ipPort != '-'
           source = event.get('source') || {}
           begin
             port = Integer(ipPort)
           rescue
             port = ipPort
           end
           source['port'] = port
           event.set('source', source)
           winlog = event.get('winlog') || {}
           event_data = winlog['event_data'] || {}
           event_data.delete('IpPort')
           winlog['event_data'] = event_data
           event.set('winlog', winlog)
         end

         # Process WorkstationName: If exists, set source.domain and remove WorkstationName.
         workstationName = event.get('[winlog][event_data][WorkstationName]')
         if workstationName
           source = event.get('source') || {}
           source['domain'] = workstationName
           event.set('source', source)
           winlog = event.get('winlog') || {}
           event_data = winlog['event_data'] || {}
           event_data.delete('WorkstationName')
           winlog['event_data'] = event_data
           event.set('winlog', winlog)
         end

         # Process ClientAddress: If exists and not '-', set to related.ip and remove ClientAddress.
         clientAddress = event.get('[winlog][event_data][ClientAddress]')
         if clientAddress and clientAddress != '-'
           related = event.get('related') || {}
           related['ip'] = clientAddress
           event.set('related', related)
           winlog = event.get('winlog') || {}
           event_data = winlog['event_data'] || {}
           event_data.delete('ClientAddress')
           winlog['event_data'] = event_data
           event.set('winlog', winlog)
         end

         # Set process.name if not set and process.executable exists:
         proc_obj = event.get('process') || {}
         if proc_obj['name'].nil? and proc_obj['executable']
           parts = proc_obj['executable'].split('\\\\')
           proc_obj['name'] = parts[-1]
           event.set('process', proc_obj)
         end
       "
     }
   }
 
   
   
   #Process Event 4688
   if ([event][code] and ([event][code] in ["4688"])) {
     ruby {
       code => "
         # Process NewProcessId: Set process.pid from winlog.event_data.NewProcessId and remove the field.
         new_pid = event.get('[winlog][event_data][NewProcessId]')
         if new_pid
           proc_obj = event.get('process') || {}
           if new_pid.is_a?(String)
             begin
               pid = Integer(new_pid)
             rescue
               pid = new_pid
             end
             proc_obj['pid'] = pid
           else
             proc_obj['pid'] = new_pid
           end
           event.set('process', proc_obj)
           winlog = event.get('winlog') || {}
           event_data = winlog['event_data'] || {}
           event_data.delete('NewProcessId')
           winlog['event_data'] = event_data
           event.set('winlog', winlog)
         end

         # Process NewProcessName: Set process.executable from winlog.event_data.NewProcessName and remove the field.
         new_proc_name = event.get('[winlog][event_data][NewProcessName]')
         if new_proc_name
           proc_obj = event.get('process') || {}
           proc_obj['executable'] = new_proc_name
           event.set('process', proc_obj)
           winlog = event.get('winlog') || {}
           event_data = winlog['event_data'] || {}
           event_data.delete('NewProcessName')
           winlog['event_data'] = event_data
           event.set('winlog', winlog)
         end

         # Process ParentProcessName: Set process.parent.executable from winlog.event_data.ParentProcessName and remove the field.
         parent_proc_name = event.get('[winlog][event_data][ParentProcessName]')
         if parent_proc_name
           proc_obj = event.get('process') || {}
           parent_obj = proc_obj['parent'] || {}
           parent_obj['executable'] = parent_proc_name
           proc_obj['parent'] = parent_obj
           event.set('process', proc_obj)
           winlog = event.get('winlog') || {}
           event_data = winlog['event_data'] || {}
           event_data.delete('ParentProcessName')
           winlog['event_data'] = event_data
           event.set('winlog', winlog)
         end

         # If process.name is not set and process.executable exists, extract the name from executable.
         proc_obj = event.get('process') || {}
         if proc_obj['name'].nil? and proc_obj['executable']
           parts = proc_obj['executable'].split('\\\\')
           proc_obj['name'] = parts.last
           event.set('process', proc_obj)
         end

         # If process.parent.name is not set and process.parent.executable exists, extract the parent name.
         if proc_obj['parent']
           parent_obj = proc_obj['parent']
           if parent_obj['name'].nil? and parent_obj['executable']
             parts = parent_obj['executable'].split('\\\\')
             parent_obj['name'] = parts.last
             proc_obj['parent'] = parent_obj
             event.set('process', proc_obj)
           end
         end

         # Process ProcessId: Set process.parent.pid from winlog.event_data.ProcessId.
         parent_pid = event.get('[winlog][event_data][ProcessId]')
         if parent_pid
           proc_obj = event.get('process') || {}
           parent_obj = proc_obj['parent'] || {}
           if parent_pid.is_a?(String)
             begin
               pid = Integer(parent_pid)
             rescue
               pid = parent_pid
             end
             parent_obj['pid'] = pid
           else
             parent_obj['pid'] = parent_pid
           end
           proc_obj['parent'] = parent_obj
           event.set('process', proc_obj)
         end

         # Process CommandLine: Parse the command line into arguments.
         cmd_line = event.get('[winlog][event_data][CommandLine]')
         if cmd_line
           args = []
           start_idx = 0
           in_quote = false
           len = cmd_line.length
           for i in 0...len
             char = cmd_line[i]
             if char == '\"'
               in_quote = !in_quote
             end
             if char =~ /\\s/ and !in_quote
               token = cmd_line[start_idx...i]
               if token.strip != ''
                 args << token.strip
               end
               start_idx = i + 1
             end
             if i == len - 1
               token = cmd_line[start_idx..-1]
               if token.strip != ''
                 args << token.strip
               end
             end
           end
           proc_obj = event.get('process') || {}
           proc_obj['args'] = args
           proc_obj['command_line'] = cmd_line
           event.set('process', proc_obj)
         end

         # Process TargetUserName: Add winlog.event_data.TargetUserName to related.user.
         targetUserName = event.get('[winlog][event_data][TargetUserName]')
         if targetUserName
           related = event.get('related') || {}
           related_user = related['user'] || []
           if !related_user.include?(targetUserName)
             related_user << targetUserName
           end
           related['user'] = related_user
           event.set('related', related)
         end
       "
     }
   }


   #Appends "{{winlog.event_data.SubjectUserName}}" to the "related.user" field
   if ([event][code] and ([event][code] in ["4624", "4648", "4797", "5379", "5380", "5381", "5382"]) and [winlog][event_data][SubjectUserName] and ([winlog][event_data][SubjectUserName] != "-")) {
     ruby {
       code => "
         # Retrieve the existing 'related' object or initialize it as an empty hash.
         related = event.get('related') || {}
         # Retrieve the 'related.user' array or initialize it.
         related_user = related['user'] || []
      
         # Get the SubjectUserName from winlog.event_data.
         subjectUserName = event.get('[winlog][event_data][SubjectUserName]')
      
         # Append the SubjectUserName if it is not already present.
         if !related_user.include?(subjectUserName)
           related_user << subjectUserName
         end
      
         # Set the updated array back into the related object.
         related['user'] = related_user
         event.set('related', related)
       "
     }
   }
   

   #Appends "{{winlog.event_data.TargetUserName}}" to the "related.user" field
   if ([event][code] and ([event][code] in ["4688", "4720", "4722", "4723", "4724", "4725", "4726", "4738", "4740", "4767", "4797", "4798"]) and [winlog][event_data][TargetUserName] and ([winlog][event_data][TargetUserName] != "-")) {
     ruby {
       code => "
         # Retrieve or initialize the 'related' object and its 'user' array.
         related = event.get('related') || {}
         related_user = related['user'] || []

         # Get the TargetUserName from winlog.event_data.
         targetUserName = event.get('[winlog][event_data][TargetUserName]')

         # Append the TargetUserName if it is not already present.
         if !related_user.include?(targetUserName)
           related_user << targetUserName
         end

         # Update the 'related' object in the event.
         related['user'] = related_user
         event.set('related', related)
       "
     }
   }


   #Splits the string stored in "winlog.event_data.PrivilegeList" to an array
   if ([event][code] and ([event][code] in ["4672", "4673", "4674", "4741", "4742", "4743"]) and [winlog][event_data][PrivilegeList]) {
     mutate {
       # Replace any sequence of whitespace (spaces, newlines, tabs, etc.) with a single space.
       gsub => [ "[winlog][event_data][PrivilegeList]", "\\s+", " " ]
       # Now split the field using a single space as the delimiter.
       split => { "[winlog][event_data][PrivilegeList]" => " " }
     }
   }

   #Alternative in Ruby
   #if ([event][code] and ([event][code] in ["4672", "4673", "4674", "4741", "4742", "4743"]) and [winlog][event_data][PrivilegeList]) {
    # ruby {
    #   code => "
     #    # Retrieve the PrivilegeList string from winlog.event_data.
      #   priv_list = event.get('[winlog][event_data][PrivilegeList]')
       #  if priv_list
       #    # Split the string using one or more whitespace characters as the separator.
       #    priv_array = priv_list.split(/\s+/)
       #    # Replace the original string with the resulting array.
       #    event.set('[winlog][event_data][PrivilegeList]', priv_array)
       #  end
       #"
     #}
   #}


   #Sets value of "user.target.name" to the value of "winlog.event_data.OldTargetUserName"
   if ([winlog][event_data][OldTargetUserName] and ([winlog][event_data][OldTargetUserName] != "")) {
     ruby {
       code => "
         # Get the value of winlog.event_data.OldTargetUserName
         new_name = event.get('[winlog][event_data][OldTargetUserName]')
         # Retrieve or initialize the 'user' object
         user = event.get('user') || {}
         # Retrieve or initialize the nested 'target' object within 'user'
         target = user['target'] || {}
         # Set (or override) target.name with the new value
         target['name'] = new_name
         # Update the user object with the modified target
         user['target'] = target
         event.set('user', user)
       "
     }
   }
  

   #Sets value of "user.changes.name" to the value of "winlog.event_data.NewTargetUserName"
   if ([winlog][event_data][NewTargetUserName] and ([winlog][event_data][NewTargetUserName] != "")) {
     ruby {
       code => "
         # Retrieve the new target user name from winlog.event_data.
         new_target = event.get('[winlog][event_data][NewTargetUserName]')  
         # Retrieve or initialize the 'user' object.
         user = event.get('user') || {}
         # Retrieve or initialize the 'changes' sub-object within 'user'.
         changes = user['changes'] || {}
         # Override changes.name with the new target user name.
         changes['name'] = new_target
         # Update the user object with the modified changes.
         user['changes'] = changes
         event.set('user', user)
       "
     }
   }
   

   #Appends "{{winlog.event_data.NewTargetUserName}}" to the "related.user" field
   if ([winlog][event_data][NewTargetUserName] and ([winlog][event_data][NewTargetUserName] != "-")) {
     ruby {
       code => "
         # Retrieve the NewTargetUserName value.
         new_target = event.get('[winlog][event_data][NewTargetUserName]')
         # Retrieve or initialize the 'related' object.
         related = event.get('related') || {}
         # Retrieve or initialize the 'related.user' array.
         related_user = related['user'] || []
         # Append new_target if it's not already in the array.
         if !related_user.include?(new_target)
           related_user << new_target
         end   
         # Update the 'related' object with the new user array.
         related['user'] = related_user
         event.set('related', related)
       "
     }
   }
   

   #Appends "{{winlog.event_data.OldTargetUserName}}" to the "related.user" field
   if ([winlog][event_data][OldTargetUserName] and ([winlog][event_data][OldTargetUserName] != "-")) {
     ruby {
       code => "
         # Retrieve the OldTargetUserName value.
         old_target = event.get('[winlog][event_data][OldTargetUserName]')   
         # Retrieve or initialize the 'related' object.
         related = event.get('related') || {}
         # Retrieve or initialize the 'related.user' array.
         related_user = related['user'] || []
         # Append the old target user name if it is not already present.
         if !related_user.include?(old_target)
           related_user << old_target
         end
         # Update the 'related' object with the new user array.
         related['user'] = related_user
         event.set('related', related)
       "
     }
   }


   #Replaces value matching "::ffff:" in source.ip with ""
   mutate { gsub => [ "[source][ip]", "::ffff:", "" ] }
   

   #Appends "{{source.ip}} to the "related.ip" field
   if ([source][ip] and ([source][ip] != "-")) {
     ruby {
       code => "
         # Retrieve the source IP value.
         source_ip = event.get('[source][ip]')      
         # Retrieve or initialize the 'related' object.
         related = event.get('related') || {}
         # Retrieve or initialize the 'related.ip' array.
         related_ip = related['ip'] || []
         # Append source_ip if not already present.
         if !related_ip.include?(source_ip)
           related_ip << source_ip
         end
         # Update the 'related' object with the new ip array.
         related['ip'] = related_ip
         event.set('related', related)
       "
     }
   }


   #Object Policy Change and SidListDesc
   if ([event][code] and ([event][code] in ["4670", "4817", "4907", "4908"])) {
     ruby {
       init => "
         require 'csv'
      
         # Load parameters from CSV files into a hash called 'params'
         params = {}

         # Load AceTypes from AceTypes.csv
         params['AceTypes'] = {}
         CSV.foreach('/usr/share/logstash/pipeline/winlogbeat/csv/security/Windows-ObjectPolicySidList_AceTypes.csv', headers: true) do |row|
           params['AceTypes'][row['Code']] = row['Description']
         end

         # Load AccountSIDDescription from AccountSIDDescription.csv
         params['AccountSIDDescription'] = {}
         CSV.foreach('/usr/share/logstash/pipeline/winlogbeat/csv/security/Windows-ObjectPolicySidList_AccountSIDDescription.csv', headers: true) do |row|
           params['AccountSIDDescription'][row['Code']] = row['Description']
         end

         # Load DomainSpecificSID from DomainSpecificSID.csv
         params['DomainSpecificSID'] = {}
         CSV.foreach('/usr/share/logstash/pipeline/winlogbeat/csv/security/Windows-ObjectPolicySidList_DomainSpecificSID.csv', headers: true) do |row|
           params['DomainSpecificSID'][row['Code']] = row['Description']
         end

         # Load PermsFlags from PermsFlags.csv
         params['PermsFlags'] = {}
         CSV.foreach('/usr/share/logstash/pipeline/winlogbeat/csv/security/Windows-ObjectPolicySidList_PermsFlags.csv', headers: true) do |row|
           params['PermsFlags'][row['Code']] = row['Description']
         end

         # Load PermissionDescription from PermissionDescription.csv
         params['PermissionDescription'] = {}
         CSV.foreach('/usr/share/logstash/pipeline/winlogbeat/csv/security/Windows-ObjectPolicySidList_PermissionDescription.csv', headers: true) do |row|
           params['PermissionDescription'][row['Code']] = row['Description']
         end

         # Define translatePermissionMask: converts a hex mask to a number and
         # checks which permission flags (from params['PermsFlags']) are set.
         def translatePermissionMask(mask, params)
           al = []
           permCode = mask.to_i(16)
           params['PermsFlags'].each do |key, value|
             permFlag = key.to_i(16)
             if (permCode & permFlag) == permFlag
               al << value
             end
           end
           al = [mask] if al.empty?
           al
         end

         # Define translateSID: translates a SID using params['AccountSIDDescription'].
         # If not found and the SID starts with 'S-1-5-21', extracts trailing digits
         # to attempt a lookup in params['DomainSpecificSID'].
         def translateSID(sid, params)
           if !params['AccountSIDDescription'].has_key?(sid)
             if sid.start_with?('S-1-5-21')
               uidPattern = /[0-9]{1,5}$/
               uidMatch = uidPattern.match(sid)
               if uidMatch
                 return params['DomainSpecificSID'][uidMatch[0]] || sid
               end
               return sid
             end
             return sid
           end
           return params['AccountSIDDescription'][sid]
         end

         # Define translateACL: splits an ACE string (dacl) by semicolon and translates
         # its parts (grantee, type, and permissions).
         def translateACL(dacl, params)
           aceArray = dacl.split(';')
           hm = {}
           hm['grantee'] = translateSID(aceArray[5], params) if aceArray.length >= 6
           hm['type'] = params['AceTypes'][aceArray[0]] if aceArray.length >= 1
           if aceArray.length >= 3
             if aceArray[2].start_with?('0x')
               hm['perms'] = translatePermissionMask(aceArray[2], params)
             else
               al = []
               aceArray[2].scan(/.{1,2}/) do |grp|
                 al << params['PermissionDescription'][grp]
               end
               hm['perms'] = al
             end
           end
           hm
         end

         # Define enrichSDDL: processes an SDDL string, extracting the Owner, Group,
         # DACL and SACL. It stores the translated values in fields prefixed with sd.
         def enrichSDDL(sddlStr, sd, params, event)
           # Process Owner (e.g., 'O:XX')
           sdOwnerPattern = /^O\:[A-Z]{2}/
           sdOwnerMatch = sddlStr.match(sdOwnerPattern)
           if sdOwnerMatch
             winlog = event.get('winlog') || {}
             event_data = winlog['event_data'] || {}
             event_data[sd + 'Owner'] = translateSID(sdOwnerMatch[0], params)
             winlog['event_data'] = event_data
             event.set('winlog', winlog)
           end

           # Process Group (e.g., 'G:XX')
           sdGroupPattern = /^G\:[A-Z]{2}/
           sdGroupMatch = sddlStr.match(sdGroupPattern)
           if sdGroupMatch
             winlog = event.get('winlog') || {}
             event_data = winlog['event_data'] || {}
             event_data[sd + 'Group'] = translateSID(sdGroupMatch[0], params)
             winlog['event_data'] = event_data
             event.set('winlog', winlog)
           end

           # Process DACL
           sdDaclPattern = /(D:([A-Z]*(\(.*\))*))/
           sdDaclMatch = sddlStr.match(sdDaclPattern)
           if sdDaclMatch
             dacList = sdDaclMatch[1].scan(/\([^*\)]*\)/)
             dacList.each_with_index do |dacl, i|
               dacl_clean = dacl.gsub('(', '').gsub(')', '')
               newDacl = translateACL(dacl_clean, params)
               daclStr = newDacl['grantee'] + ' :' + newDacl['type'] + ' (' + newDacl['perms'].to_s + ')'
               winlog = event.get('winlog') || {}
               event_data = winlog['event_data'] || {}
               event_data[sd + 'Dacl' + i.to_s] = daclStr
               winlog['event_data'] = event_data
               event.set('winlog', winlog)
               if ['Administrator', 'Guest', 'KRBTGT'].include?(newDacl['grantee'])
                 related = event.get('related') || {}
                 related_user = related['user'] || []
                 unless related_user.include?(newDacl['grantee'])
                   related_user << newDacl['grantee']
                 end
                 related['user'] = related_user
                 event.set('related', related)
               end
             end
           end

           # Process SACL
           sdSaclPattern = /(S:([A-Z]*(\(.*\))*))?$/
           sdSaclMatch = sddlStr.match(sdSaclPattern)
           if sdSaclMatch
             sacList = sdSaclMatch[0].scan(/\([^*\)]*\)/)
             sacList.each_with_index do |sacl, i|
               sacl_clean = sacl.gsub('(', '').gsub(')', '')
               newSacl = translateACL(sacl_clean, params)
               saclStr = newSacl['grantee'] + ' :' + newSacl['type'] + ' (' + newSacl['perms'].to_s + ')'
               winlog = event.get('winlog') || {}
               event_data = winlog['event_data'] || {}
               event_data[sd + 'Sacl' + i.to_s] = saclStr
               winlog['event_data'] = event_data
               event.set('winlog', winlog)
               if ['Administrator', 'Guest', 'KRBTGT'].include?(newSacl['grantee'])
                 related = event.get('related') || {}
                 related_user = related['user'] || []
                 unless related_user.include?(newSacl['grantee'])
                   related_user << newSacl['grantee']
                 end
                 related['user'] = related_user
                 event.set('related', related)
               end
             end
           end
         end

         # Define a manual split function (similar to the Painless split).
         def split_string(s)
           f = []
           last = 0
           while last < s.length && s[last] =~ /\\s/
             last += 1
           end
           i = last
           while i < s.length
             if s[i] !~ /\\s/
               i += 1
               next
             end
             f << s[last...i]
             while i < s.length && s[i] =~ /\\s/
               i += 1
             end
             last = i
           end
           f << s[last..-1]
           f
         end

         # Define splitSidList: splits a SID list string and translates each SID.
         def splitSidList(sids, params, event)
           list = []
           desc = []
           sidList = split_string(sids)
           sidList.each do |sid|
             list << sid
             cleaned = sid.gsub('%', '').gsub('{', '').gsub('}', '')
             desc << translateSID(cleaned, params)
           end
           winlog = event.get('winlog') || {}
           event_data = winlog['event_data'] || {}
           event_data['SidList'] = list
           event_data['SidListDesc'] = desc
           winlog['event_data'] = event_data
           event.set('winlog', winlog)
         end

         # Store the loaded parameters in a global variable for later access.
         $params = params
       "
       code => "
         # Main processing block: Execute only if the event code is one of the allowed codes.
         event_code = event.get('[event][code]')
         if event_code.nil? or !(['4670', '4817', '4907', '4908'].include?(event_code))
           return
         end

         # Retrieve parameters from the global variable.
         params = $params

         # If OldSd is present, enrich the SDDL with the prefix 'OldSd'.
         old_sd = event.get('[winlog][event_data][OldSd]')
         if old_sd
           enrichSDDL(old_sd, 'OldSd', params, event)
         end

         # If NewSd is present, enrich the SDDL with the prefix 'NewSd'.
         new_sd = event.get('[winlog][event_data][NewSd]')
         if new_sd
           enrichSDDL(new_sd, 'NewSd', params, event)
         end

         # If SidList is present, split the SID list and translate each SID.
         sid_list = event.get('[winlog][event_data][SidList]')
         if sid_list
           splitSidList(sid_list, params, event)
         end
       "
     }
   }


   #Sets value of "file.name" to the value of "winlog.event_data.RelativeTargetName"
   if ([event][code] and ([event][code] in ["5140", "5145"]) and [winlog][event_data][RelativeTargetName] and ([winlog][event_data][RelativeTargetName] != "")) {
     mutate { replace => { "file.name" => "%{[winlog][event_data][RelativeTargetName]}" } }
   }


   #Sets value of "file.directory" to the value of "winlog.event_data.ShareLocalPath"
   if ([event][code] and ([event][code] in ["5140", "5145"]) and [winlog][event_data][ShareLocalPath] and ([winlog][event_data][ShareLocalPath] != "")) {
     mutate { replace => { "file.name" => "%{[winlog][event_data][ShareLocalPath]}" } }
   }

   #Sets value of "file.path" to "{{file.directory}}\\{{file.name}}"
   if ([file][name] and [file][directory]) {
     mutate { replace => { "file.path" => "%{[file][directory]}\\%{[file][name]}" } }
   }


   #Sets value of "file.target_path" to "{{winlog.event_data.ShareName}}\\{{file.name}}"
   if ([event][code] and ([event][code] in ["5140", "5145"]) and [winlog][event_data][ShareName] and ([winlog][event_data][ShareName] != "") and [file][name]) {
     mutate { replace => { "file.target_path" => "%{[winlog][event_data][ShareName]}\\%{[file][name]}" } }
   }


   #Adds file information
   if ([file][name]) {
     ruby {
       code => "
         fname = event.get('[file][name]')
         ext_idx = fname.rindex('.')
         if ext_idx
           extension = fname[ext_idx+1..-1]
           event.set('[file][extension]', extension)
         end
       "
     }
   }


   #Converts "winlog.record_id" to type "string"
   mutate { convert => { "[winlog][record_id]" => "string" } }

   #Converts "winlog.event_id" to type "string"
   mutate { convert => { "[winlog][event_id]" => "string" } }


   #Sets value of "log.level" to the value of "winlog.level"
   if ([winlog][level] and ([winlog][level] != "")) {
     mutate { replace => { "log.level" => "%{[winlog][level]}" } }
   }   

   #Parse a date from "winlog.time_created" to a date type on field "@timestamp"
   if ([winlog][time_created]) {
     date { 
       match => ["[winlog][time_created]", "ISO8601"]
       target => "@timestamp"
     }
   }

   #Remove event.original as it is not needed, duplicate of field message
   mutate { remove_field => ["[event][original]"] }
   

 }
}
